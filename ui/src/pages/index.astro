---
// Main dashboard page - Refactorizado y modularizado
import Header from "../components/Header.astro";
import SlavesPanel from "../components/SlavesPanel.astro";
import ConfigPanel from "../components/ConfigPanel.astro";
import ControlPanel from "../components/ControlPanel.astro";
import TelemetryPanel from "../components/TelemetryPanel.astro";
import PreviewPanel from "../components/PreviewPanel.astro";
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content={Astro.generator} />
    <title>WPlace Master Dashboard</title>
    <style>
      :root {
        --background: 0 0% 100%;
        --foreground: 222.2 84% 4.9%;
        --card: 0 0% 100%;
        --card-foreground: 222.2 84% 4.9%;
        --popover: 0 0% 100%;
        --popover-foreground: 222.2 84% 4.9%;
        --primary: 222.2 47.4% 11.2%;
        --primary-foreground: 210 40% 98%;
        --secondary: 210 40% 96%;
        --secondary-foreground: 222.2 84% 4.9%;
        --muted: 210 40% 96%;
        --muted-foreground: 215.4 16.3% 46.9%;
        --accent: 210 40% 96%;
        --accent-foreground: 222.2 84% 4.9%;
        --destructive: 0 84.2% 60.2%;
        --destructive-foreground: 210 40% 98%;
        --border: 214.3 31.8% 91.4%;
        --input: 214.3 31.8% 91.4%;
        --ring: 222.2 84% 4.9%;
        --radius: 0.5rem;
      }
      
      .dark {
        --background: 222.2 84% 4.9%;
        --foreground: 210 40% 98%;
        --card: 222.2 84% 4.9%;
        --card-foreground: 210 40% 98%;
        --popover: 222.2 84% 4.9%;
        --popover-foreground: 210 40% 98%;
        --primary: 210 40% 98%;
        --primary-foreground: 222.2 47.4% 11.2%;
        --secondary: 217.2 32.6% 17.5%;
        --secondary-foreground: 210 40% 98%;
        --muted: 217.2 32.6% 17.5%;
        --muted-foreground: 215 20.2% 65.1%;
        --accent: 217.2 32.6% 17.5%;
        --accent-foreground: 210 40% 98%;
        --destructive: 0 62.8% 30.6%;
        --destructive-foreground: 210 40% 98%;
        --border: 217.2 32.6% 17.5%;
        --input: 217.2 32.6% 17.5%;
        --ring: 212.7 26.8% 83.9%;
      }
    </style>
    <!-- Animaciones globales para las tarjetas de slaves -->
    <style is:global>
      @keyframes card-flash-green {
        0% { box-shadow: 0 0 0 0 rgba(16,185,129,0.0), 0 0 0 0 rgba(16,185,129,0.0) inset; }
        20% { box-shadow: 0 0 0 3px rgba(16,185,129,0.9), 0 0 18px 2px rgba(16,185,129,0.6) inset; }
        80% { box-shadow: 0 0 0 3px rgba(16,185,129,0.6), 0 0 12px 1px rgba(16,185,129,0.35) inset; }
        100% { box-shadow: 0 0 0 0 rgba(16,185,129,0.0), 0 0 0 0 rgba(16,185,129,0.0) inset; }
      }
      @keyframes card-flash-red {
        0% { box-shadow: 0 0 0 0 rgba(239,68,68,0.0), 0 0 0 0 rgba(239,68,68,0.0) inset; }
        20% { box-shadow: 0 0 0 3px rgba(239,68,68,0.9), 0 0 18px 2px rgba(239,68,68,0.6) inset; }
        80% { box-shadow: 0 0 0 3px rgba(239,68,68,0.6), 0 0 12px 1px rgba(239,68,68,0.35) inset; }
        100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.0), 0 0 0 0 rgba(239,68,68,0.0) inset; }
      }
      .flash-green { animation: card-flash-green 1.2s ease-out; }
      .flash-red { animation: card-flash-red 1.2s ease-out; }
      
      /* Animación del spinner para el botón Start */
      @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
      
      .animate-spin {
        animation: spin 1s linear infinite;
      }
      
      /* Transiciones suaves para el botón Start */
      #start-btn-text,
      #start-btn-spinner {
        transition: opacity 300ms cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      #start-btn-spinner .animate-spin {
        animation: spin 0.8s linear infinite;
      }
    </style>
  </head>
  <body class="min-h-screen bg-background font-sans antialiased">
    <div id="app">
      <!-- Header -->
      <Header />

      <!-- Main Content -->
      <main class="container mx-auto px-4 py-8">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <!-- Left column: Slaves + Config stacked -->
          <div class="space-y-6 lg:col-span-1">
            <SlavesPanel />
            <ConfigPanel />
          </div>

          <!-- Right side: Control, Telemetry, Preview -->
          <div class="lg:col-span-2">
            <ControlPanel />
            <TelemetryPanel />
            <PreviewPanel />
          </div>
        </div>
      </main>
    </div>

    <!-- Dashboard JavaScript - Modularizado -->
    <script type="module">
      // Importar todos los módulos
      import { WebSocketManager } from '/utils/WebSocketManager.js';
import { SlaveManager } from '/utils/SlaveManager.js';
import { PreviewManager } from '/utils/PreviewManager.js';
import { SessionManager } from '/utils/SessionManager.js';
import { ConfigManager } from '/utils/ConfigManager.js';
import { UIHelpers } from '/utils/UIHelpers.js';

      /**
       * Clase principal del Dashboard WPlace - Refactorizada y modularizada
       * 
       * Esta clase coordina todos los módulos especializados y mantiene el estado global
       * de la aplicación. Cada aspecto funcional ha sido extraído a su propio módulo.
       */
      class WPlaceDashboard {
        constructor() {
          // Inicializar propiedades básicas
          this.detectedBotMode = null;
          this.projectConfig = null;
          this.activeProject = null; // alias legacy
          this.currentRoundPlan = {};
          this._recentRepairs = new Map();
          this._recentTTL = 5;
          
          // Inicializar módulos especializados
          this.uiHelpers = new UIHelpers(this);
          this.webSocketManager = new WebSocketManager(this);
          this.slaveManager = new SlaveManager(this);
          this.previewManager = new PreviewManager(this);
          this.sessionManager = new SessionManager(this);
          this.configManager = new ConfigManager(this);
          
          // Inicializar la aplicación
          this.init();
        }

        /**
         * Inicializa la aplicación y todos sus módulos
         */
        init() {
          this.webSocketManager.connect();
          this.setupEventListeners();
          this.configManager.loadGuardConfig();
          this.configManager.setupConfigPanelListeners();
          this.previewManager.restorePreviewPreferredHeight();
          
          // Estado inicial de controles
          try { 
            this.updateControlButtons(); 
          } catch {}
          try { 
            this.configManager.updateConfigPanelEnabledState(); 
          } catch {}
        }

        /**
         * Configura todos los event listeners de la aplicación
         */
        setupEventListeners() {
          // Botones de control de sesión
          document.getElementById('start-btn')?.addEventListener('click', () => 
            this.sessionManager.startSession());
          document.getElementById('pause-btn')?.addEventListener('click', () => 
            this.sessionManager.pauseSession());
          document.getElementById('stop-btn')?.addEventListener('click', () => 
            this.sessionManager.stopSession());
          
          // Botones de lote individual
          const oneBatchBtn = document.getElementById('one-batch-btn');
          if (oneBatchBtn) {
            oneBatchBtn.addEventListener('click', () => this.sessionManager.sendOneBatch());
          }
          
          // Controles de preview
          const fitZoomBtn = document.getElementById('fit-zoom');
          if (fitZoomBtn) {
            fitZoomBtn.addEventListener('click', () => this.previewManager.fitZoom());
          }
          
          const zoomSlider = document.getElementById('zoom-slider');
          if (zoomSlider) {
            zoomSlider.addEventListener('input', (e) => {
              const desired = parseFloat(e.target.value);
              this.previewManager.setZoom(desired);
            });
          }
          
          // Manejo de archivos de proyecto
          document.getElementById('project-file')?.addEventListener('change', (e) => 
            this.sessionManager.handleFileChange(e));
          
          // Botón de limpiar proyecto
          const clearBtn = document.getElementById('clear-project-btn');
          if (clearBtn) {
            clearBtn.addEventListener('click', () => this.sessionManager.clearProject());
          }

          // Resizer del preview
          this.setupPreviewResizer();
          
          // Logs collapsible
          this.setupLogsToggle();
          
          // Window resize handler
          window.addEventListener('resize', () => {
            const previewPanel = document.getElementById('preview-panel');
            if (previewPanel && previewPanel.style.display !== 'none') {
              this.previewManager.adjustPreviewSize();
            }
          });

          // Listener genérico para toggles de slaves
          document.addEventListener('change', (e) => {
            const target = e.target;
            if (target && target.classList && target.classList.contains('slave-toggle')) {
              this.updateControlButtons();
              this.recomputeRoundPlan();
            }
          });
        }

        /**
         * Configura el resizer del panel de preview
         */
        setupPreviewResizer() {
          const resizer = document.getElementById('preview-resizer');
          if (!resizer) return;
          
          let isResizing = false;
          let startY = 0;
          let startH = 0;
          
          resizer.addEventListener('mousedown', (e) => {
            const content = document.getElementById('preview-content');
            if (!content) return;
            
            isResizing = true;
            startY = e.clientY;
            startH = content.offsetHeight;
            document.body.style.cursor = 'ns-resize';
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
          });
          
          const onMove = (e) => {
            if (!isResizing) return;
            const content = document.getElementById('preview-content');
            if (!content) return;
            
            const delta = e.clientY - startY;
            const next = Math.max(520, Math.min(window.innerHeight * 0.95, startH + delta));
            content.style.height = `${Math.round(next)}px`;
            this.previewManager.persistPreviewPreferredHeight(Math.round(next));
            this.previewManager.fitZoom();
          };
          
          const onUp = () => {
            if (!isResizing) return;
            isResizing = false;
            document.body.style.cursor = 'default';
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
          };
        }

        /**
         * Configura el toggle de logs colapsable
         */
        setupLogsToggle() {
          const logsToggle = document.getElementById('logs-toggle');
          const logsCaret = document.getElementById('logs-caret');
          const logsWrapper = document.getElementById('logs-wrapper');
          
          if (logsToggle && logsCaret && logsWrapper) {
            logsToggle.addEventListener('click', () => {
              const open = logsWrapper.style.maxHeight && parseInt(logsWrapper.style.maxHeight) > 0;
              if (open) {
                logsWrapper.style.maxHeight = '0px';
                logsCaret.style.transform = 'rotate(-90deg)';
              } else {
                logsWrapper.style.maxHeight = '220px';
                logsCaret.style.transform = 'rotate(0deg)';
              }
            });
          }
        }

        /**
         * Maneja los mensajes WebSocket recibidos
         */
        handleWebSocketMessage(message) {
          this.uiHelpers.logOnce(`proc:${message.type}`, `🔄 Processing message type: ${message.type}`, 1200);
          
          switch (message.type) {
            case 'projects_cleared':
              this.handleProjectsCleared();
              break;
            case 'initial_state':
              this.handleInitialState(message);
              break;
            case 'slave_connected':
            case 'slave_reconnected':
              this.handleSlaveConnected(message);
              break;
            case 'slave_disconnected':
              this.handleSlaveDisconnected(message);
              break;
            case 'ui_selected_slaves':
              this.handleUISelectedSlaves(message);
              break;
            case 'telemetry_update':
              this.handleTelemetryUpdate(message);
              break;
            case 'status_update':
              this.handleStatusUpdate(message);
              break;
            case 'slave_favorite':
              this.handleSlaveFavorite(message);
              break;
            case 'preview_data':
              this.handlePreviewData(message);
              break;
            case 'repair_ack':
            case 'repair_progress':
            case 'repair_complete':
            case 'repair_error':
              this.handleRepairMessages(message);
              break;
            case 'paint_progress':
            case 'paint_result':
              this.handlePaintMessages(message);
              break;
            case 'guard_config':
              this.handleGuardConfig(message);
              break;
            case 'guard_cleared':
              this.handleGuardCleared(message);
              break;
            case 'guard_upload_sent':
              this.handleGuardUploadSent(message);
              break;
            case 'log':
              this.log(`[${message.slave_id}] ${message.message}`);
              break;
            default:
              this.log(`❓ Unknown message type: ${message.type}`);
              console.log('Full unknown message:', message);
          }
        }

        /**
         * Maneja el mensaje de proyectos limpiados
         */
        handleProjectsCleared() {
          this.log('🧹 Proyecto(s) limpiado(s)');
          try {
            const statusEl = document.getElementById('file-status');
            if (statusEl) statusEl.textContent = 'No file selected';
            
            this.activeProject = null;
            this.projectConfig = null;
            this.detectedBotMode = null;
            this.previewManager.lastPreviewData = null;
            this.previewManager.previewChanges = [];
            this.previewManager.previewMeta = {};
            this.previewManager.guardPreview = {
              analysis: null,
              togglesInitialized: false,
              show: { correct: true, incorrect: true, missing: true },
              area: null
            };
            
            const panel = document.getElementById('preview-panel');
            if (panel) panel.style.display = 'none';
            
            ['repaired-pixels', 'incorrect-pixels', 'missing-pixels'].forEach(id => {
              const el = document.getElementById(id);
              if (el) el.textContent = '0';
            });
            
            try {
              localStorage.removeItem('previewPanel.height');
            } catch {}
            
            this.updateControlButtons();
          } catch {}
          this.previewManager.renderPreview();
        }

        /**
         * Maneja el estado inicial recibido del servidor
         */
        handleInitialState(message) {
          this.log(`📋 Initial state received with ${(message.slaves || []).length} slaves`);
          this.slaveManager.updateSlavesList(message.slaves || []);
          
          try {
            if (Array.isArray(message.selected_slaves)) {
              this.slaveManager._selectedSlavesServer = new Set(message.selected_slaves);
            }
            
            // Rehidratar paleta de colores si el backend la envía
            if (Array.isArray(message.available_colors) && message.available_colors.length > 0) {
              if (!this.previewManager.lastPreviewData) {
                this.previewManager.lastPreviewData = {};
              }
              const hasPalette = Array.isArray(this.previewManager.lastPreviewData.availableColors) && 
                               this.previewManager.lastPreviewData.availableColors.length > 0;
              if (!hasPalette) {
                this.previewManager.lastPreviewData.availableColors = message.available_colors;
                this.log('🎨 Paleta cargada desde initial_state');
                try {
                  this.configManager.renderAllInlineChips();
                } catch {}
              }
            }
            
            // Procesar datos de preview del favorito si existen
            const fav = (message.slaves || []).find(s => s.is_favorite && s.telemetry && s.telemetry.preview_data);
            if (fav) {
              this.handleFavoritePreviewData(fav);
            }
            
            // Rehidratar sesión/proyecto si existen en servidor
            this.handleSessionRehydration(message);
            
            // Autoasignar favorito si es necesario
            this.autoAssignFavoriteIfNeeded();
            
            // Pedir refresh para reanudar flujo de preview tras recarga
            try {
              this.previewManager.requestPreviewRefreshThrottle();
            } catch {}
          } catch (e) {
            this.log('Error loading persisted preview: ' + e.message);
          }
        }

        /**
         * Maneja los datos de preview del slave favorito
         */
        handleFavoritePreviewData(fav) {
          this.log(`🔁 Loading persisted preview from favorite slave ${fav.id}`);
          
          try {
            const pd = fav.telemetry.preview_data;
            const looksGuard = !!(pd && (pd.protectedArea || pd.area || pd.correctPixelsList || 
                                 pd.incorrectPixelsList || pd.missingPixelsList || pd.analysis));
            const looksImage = !!(pd && (pd.imageData && (pd.imageData.fullPixelData || 
                                 (pd.imageData.width && pd.imageData.height))));
            
            if (looksGuard) this.detectedBotMode = 'Guard';
            else if (looksImage) this.detectedBotMode = 'Image';
            
            const detectedEl = document.getElementById('detected-mode');
            if (detectedEl) {
              detectedEl.textContent = this.detectedBotMode ? 
                `Detected mode: ${this.detectedBotMode}` : 
                'No file loaded - mode will be auto-detected';
            }
          } catch {}
          
          this.previewManager.updatePreviewFromSlave(message.slave_id, message.data);
          this.previewManager.renderGuardPreviewCanvas(fav.telemetry.preview_data);
          
          try {
            this.updateControlButtons();
          } catch {}
        }

        /**
         * Maneja la rehidratación de sesiones desde el servidor
         */
        handleSessionRehydration(message) {
          const sessions = Array.isArray(message.sessions) ? message.sessions : [];
          const projects = Array.isArray(message.projects) ? message.projects : [];
          
          // Elegir sesión activa: preferir 'running', si no, 'paused'
          const running = sessions.find(s => s.status === 'running');
          const paused = sessions.find(s => s.status === 'paused');
          const sess = running || paused || sessions[0];
          
          if (sess) {
            this.sessionManager.currentSession = sess.id || sess.session_id || null;
            this.sessionManager.sessionStatus = sess.status || null;
            this.log(`♻️ Rehydrated session: ${this.sessionManager.currentSession} (status=${sess.status || 'unknown'})`);
            
            // Preseleccionar slaves de la sesión
            if (Array.isArray(sess.slave_ids)) {
              setTimeout(() => {
                try {
                  const ids = new Set(sess.slave_ids);
                  document.querySelectorAll('.slave-toggle').forEach(cb => {
                    cb.checked = ids.has(cb.value);
                    this.updateToggleState(cb.id, cb.checked);
                  });
                  this.updateControlButtons();
                } catch {}
              }, 50);
            }
            
            // Cargar proyecto asociado
            const proj = projects.find(p => (p.id === sess.project_id));
            if (proj) {
              this.handleProjectRehydration(proj);
            }
            
            // Actualizar botones según estado
            this.updateSessionButtonsFromStatus(sess.status);
            
            try {
              this.updateControlButtons();
            } catch {}
          } else if (projects.length > 0) {
            // Si no hay sesiones pero sí proyectos, cargar el primer proyecto disponible
            this.log(`♻️ No sessions found, but ${projects.length} projects available. Loading first project.`);
            const proj = projects[0];
            if (proj) {
              this.handleProjectRehydration(proj);
            }
          }
        }

        /**
         * Maneja la rehidratación de proyectos
         */
        handleProjectRehydration(proj) {
          const m = (proj.mode || '').toString().toLowerCase();
          this.detectedBotMode = m.startsWith('guard') ? 'Guard' : 
                               (m.startsWith('image') ? 'Image' : (proj.mode || null));
          this.projectConfig = proj.config || null;
          
          const detectedEl = document.getElementById('detected-mode');
          if (detectedEl) {
            detectedEl.textContent = this.detectedBotMode ? 
              `Detected mode: ${this.detectedBotMode}` : 
              'No file loaded - mode will be auto-detected';
          }
          
          const statusEl = document.getElementById('file-status');
          if (statusEl) {
            statusEl.textContent = proj.name ? 
              `Loaded from server: ${proj.name}` : 
              'Loaded from server';
          }
          
          // Mostrar preview panel si hay datos
          const panel = document.getElementById('preview-panel');
          if (panel) panel.style.display = 'block';
          
          // Si es Guard y aún no hay preview en memoria, solicitarlo
          try {
            if ((this.detectedBotMode || '').toLowerCase().startsWith('guard') && 
                !this.previewManager.lastPreviewData) {
              this.previewManager.requestPreviewRefreshThrottle();
            }
          } catch {}
          
          // Actualizar botones de control después de rehidratar el proyecto
          try {
            this.updateControlButtons();
          } catch {}
          
          this.log(`♻️ Project rehydrated: mode=${this.detectedBotMode}, config=${!!this.projectConfig}`);
        }

        /**
         * Actualiza los botones de sesión según el estado
         */
        updateSessionButtonsFromStatus(status) {
          const startBtn = document.getElementById('start-btn');
          const pauseBtn = document.getElementById('pause-btn');
          const stopBtn = document.getElementById('stop-btn');
          const oneBatchBtn = document.getElementById('one-batch-btn');
          
          if (status === 'running') {
            if (startBtn) startBtn.disabled = true;
            if (pauseBtn) pauseBtn.disabled = false;
            if (stopBtn) stopBtn.disabled = false;
            if (oneBatchBtn) oneBatchBtn.disabled = false;
          } else if (status === 'paused') {
            if (startBtn) startBtn.disabled = false;
            if (pauseBtn) pauseBtn.disabled = true;
            if (stopBtn) stopBtn.disabled = false;
            if (oneBatchBtn) oneBatchBtn.disabled = false;
          }
        }

        /**
         * Autoasigna un slave favorito si es necesario
         */
        autoAssignFavoriteIfNeeded() {
          try {
            const anyFav = Array.from(this.slaveManager.slaves.values()).some(s => s && s.is_favorite);
            if (!anyFav && this.detectedBotMode && 
                this.detectedBotMode.toLowerCase().startsWith('guard') && 
                this.slaveManager.slaves.size > 0) {
              const first = Array.from(this.slaveManager.slaves.values())[0];
              if (first && first.id) {
                this.log(`⭐ No había favorito; autoasignando ${first.id}`);
                this.slaveManager.setFavoriteSlave(first.id).then(() => {
                  try {
                    this.previewManager.requestPreviewRefreshThrottle();
                  } catch {}
                }).catch(() => {});
              }
            }
          } catch {}
        }

        /**
         * Maneja la conexión de slaves
         */
        handleSlaveConnected(message) {
          this.log(`🤖 Slave ${message.type === 'slave_reconnected' ? 'reconnected' : 'connected'}: ${message.slave_id}`);
          setTimeout(() => {
            this.slaveManager.refreshSlaves();
            // Auto-activar el nuevo slave y persistir la selección
            setTimeout(() => {
              this._autoActivateNewSlave(message.slave_id);
            }, 200);
          }, 100);
        }

        /**
         * Auto-activa un nuevo slave y persiste la selección
         */
        async _autoActivateNewSlave(slaveId) {
          try {
            const checkbox = document.getElementById(`slave-toggle-${slaveId}`);
            if (checkbox && !checkbox.checked) {
              checkbox.checked = true;
              this.updateToggleState(checkbox.id, true);
              
              // Persistir selección localmente y en servidor
              const selected = Array.from(document.querySelectorAll('.slave-toggle:checked')).map(cb => cb.value);
              localStorage.setItem('selectedSlaves', JSON.stringify(selected));
              
              await fetch(`${this.apiBase()}/api/ui/selected-slaves`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ slave_ids: selected })
              }).catch(() => {});
              
              // Si hay una sesión activa, asignar lotes al nuevo slave
              if (this.sessionManager.sessionStatus === 'running') {
                await this._assignBatchesToNewSlave(slaveId);
              }
              
              this.updateControlButtons();
              this.recomputeRoundPlan();
              
              this.log(`✅ Auto-activated slave: ${slaveId}`);
            }
          } catch (error) {
            console.error('Error auto-activating slave:', error);
          }
        }

        /**
         * Asigna lotes a un nuevo slave durante una sesión activa
         */
        async _assignBatchesToNewSlave(slaveId) {
          try {
            // Obtener información del proyecto actual
            if (!this.detectedBotMode || !this.projectConfig) {
              this.log(`⚠️ No project loaded, cannot assign batches to new slave ${slaveId}`);
              return;
            }
            
            // Actualizar la sesión para incluir el nuevo slave
            if (this.sessionManager.currentSession) {
              const currentSelectedSlaves = Array.from(document.querySelectorAll('.slave-toggle:checked')).map(cb => cb.value);
              
              // Actualizar slaves en la sesión existente
              const updateResponse = await fetch(`${this.apiBase()}/api/sessions/${this.sessionManager.currentSession}/update-slaves`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ slave_ids: currentSelectedSlaves })
              });
              
              if (updateResponse.ok) {
                this.log(`🎯 Updated session with new slave ${slaveId} - batches will be assigned automatically`);
              } else {
                this.log(`⚠️ Failed to update session with new slave ${slaveId}`);
              }
            }
          } catch (error) {
            this.log(`❌ Error assigning batches to new slave ${slaveId}: ${error}`);
          }
        }

        /**
         * Maneja la desconexión de slaves
         */
        handleSlaveDisconnected(message) {
          this.log(`🔌 Slave disconnected: ${message.slave_id}`);
          this.slaveManager.slaves.delete(message.slave_id);
          this.slaveManager.displaySlaves();
        }

        /**
         * Maneja la selección de slaves desde la UI
         */
        handleUISelectedSlaves(message) {
          if (Array.isArray(message.slave_ids)) {
            this.slaveManager._selectedSlavesServer = new Set(message.slave_ids);
            if (this.slaveManager.slaves.size > 0) {
              this.slaveManager.applyServerSelection();
            } else {
              this.slaveManager.displaySlaves();
            }
          }
        }

        /**
         * Maneja las actualizaciones de telemetría
         */
        handleTelemetryUpdate(message) {
          this.log(`📈 Telemetry from ${message.slave_id}: charges=${message.telemetry?.remaining_charges || 'N/A'}`);
          this.slaveManager.updateTelemetry(message.slave_id, message.telemetry);
          
          try {
            if (message.telemetry && message.telemetry.preview_data) {
              // Envejecer bloqueos si viene del favorito
              try {
                const favId = this.slaveManager.getFavoriteSlaveId();
                if (favId && favId === message.slave_id) {
                  this.ageRecentRepairs();
                }
              } catch {}
              
              // Renderizar preview si llega embebido en telemetría
              const pd = message.telemetry.preview_data;
              
              // Fijar modo si aún no está
              if (!this.detectedBotMode) {
                const looksGuard = !!(pd && (pd.protectedArea || pd.area || pd.correctPixelsList || 
                                     pd.incorrectPixelsList || pd.missingPixelsList || pd.analysis));
                const looksImage = !!(pd && (pd.imageData && (pd.imageData.fullPixelData || 
                                     (pd.imageData.width && pd.imageData.height))));
                
                if (looksGuard) this.detectedBotMode = 'Guard';
                else if (looksImage) this.detectedBotMode = 'Image';
                
                const detectedEl = document.getElementById('detected-mode');
                if (detectedEl) {
                  detectedEl.textContent = this.detectedBotMode ? 
                    `Detected mode: ${this.detectedBotMode}` : 
                    'No file loaded - mode will be auto-detected';
                }
              }
              
              this.previewManager.updatePreviewFromSlave(message.slave_id, pd);
              this.recomputeRoundPlan();
              this.updateControlButtons();
            }
          } catch {}
        }

        /**
         * Maneja las actualizaciones de estado de slaves
         */
        handleStatusUpdate(message) {
          this.log(`📊 Status update from ${message.slave_id}: ${message.status}`);
          this.slaveManager.updateSlaveStatus(message.slave_id, message.status);
        }

        /**
         * Maneja el cambio de slave favorito
         */
        handleSlaveFavorite(message) {
          this.log(`⭐ Slave ${message.slave_id} marked as favorite`);
          this.slaveManager.slaves.forEach(s => {
            if (s) s.is_favorite = false;
          });
          if (this.slaveManager.slaves.has(message.slave_id)) {
            this.slaveManager.slaves.get(message.slave_id).is_favorite = true;
          }
          this.slaveManager.displaySlaves();
        }

        /**
         * Maneja los datos de preview
         */
        handlePreviewData(message) {
          const now = Date.now();
          if (now - this.previewManager.lastPreviewAt < 5000) {
            this.uiHelpers.logOnce('throttle:preview', '⏱️ Preview update throttled', 3000);
            return;
          }
          
          this.previewManager.lastPreviewAt = now;
          this.log(`🖼️ Preview data from ${message.slave_id}: ${message.data ? 'Data received' : 'No data'}`);
          
          if (message.data && message.data.analysis) {
            this.uiHelpers.logOnce('preview:summary', 
              `📊 Preview analysis: ${message.data.analysis.correctPixels || 0} correct, ${message.data.analysis.incorrectPixels || 0} incorrect, ${message.data.analysis.missingPixels || 0} missing`, 
              3000);
          }
          
          // Envejecer bloqueos si viene del favorito
          try {
            const favId = this.slaveManager.getFavoriteSlaveId();
            if (favId && favId === message.slave_id) {
              this.ageRecentRepairs();
            }
          } catch {}
          
          this.previewManager.updatePreviewFromSlave(message.slave_id, message.data);
          this.recomputeRoundPlan();
          
          try {
            this.updateControlButtons();
          } catch {}
        }

        /**
         * Maneja los mensajes de reparación
         */
        handleRepairMessages(message) {
          switch (message.type) {
            case 'repair_ack':
              this.uiHelpers.logOnce(`ack:${message.slave_id}:${message.total_repairs}`, 
                `🔧 Slave ${message.slave_id} acknowledged repair order: ${message.total_repairs} pixels`, 5000);
              break;
            case 'repair_progress':
              this.uiHelpers.logOnce(`prog:${message.slave_id}:${message.completed}/${message.total}`, 
                `🎨 Slave ${message.slave_id} repair progress: ${message.completed}/${message.total} pixels`, 3500);
              break;
            case 'repair_complete':
              this.uiHelpers.logOnce(`done:${message.slave_id}:${message.completed}`, 
                `✅ Slave ${message.slave_id} completed repairs: ${message.completed} pixels`, 8000);
              try {
                this.slaveManager.highlightSlaveCard(String(message.slave_id), true);
              } catch {}
              this.previewManager.requestPreviewRefreshThrottle();
              break;
            case 'repair_error':
              this.uiHelpers.logOnce(`err:${message.slave_id}:${message.error}`, 
                `❌ Slave ${message.slave_id} repair error: ${message.error}`, 8000);
              try {
                this.slaveManager.highlightSlaveCard(String(message.slave_id), false);
              } catch {}
              break;
          }
        }

        /**
         * Maneja los mensajes de pintado
         */
        handlePaintMessages(message) {
          switch (message.type) {
            case 'paint_progress':
              this.uiHelpers.logOnce(`paint:prog:${message.slave_id}:${message.tileX},${message.tileY}:${message.completed}/${message.total}`,
                `🎯 Paint progress ${message.completed}/${message.total} en tile ${message.tileX},${message.tileY} [${message.slave_id}]`, 3000);
              break;
            case 'paint_result':
              const ok = message.ok ?? message.success ?? (message.status === 'ok');
              const msg = ok ? 
                `✅ Pintado correcto (${message.painted || message.completed || 0})` : 
                `❌ Pintado fallido: ${message.error || message.status || 'unknown'}`;
              
              this.uiHelpers.logOnce(`paint:res:${message.slave_id}:${ok}:${message.painted || message.completed || 0}:${message.tileX},${message.tileY}`,
                `[${message.slave_id}] ${msg}`, 6000);
              
              try {
                this.slaveManager.highlightSlaveCard(String(message.slave_id), !!ok);
              } catch {}
              
              // Si ok y hay coords, marcar como reparados recientemente
              try {
                if (ok && Array.isArray(message.coords) && message.coords.length) {
                  this.markRecentRepairs(message.coords);
                }
              } catch {}
              
              this.previewManager.requestPreviewRefreshThrottle();
              break;
          }
        }

        /**
         * Maneja la configuración Guard
         */
        handleGuardConfig(message) {
          this.log(`⚙️ Guard config received from server`);
          if (message.config) {
            this.configManager.guardConfig = message.config;
            if (message.config.autoDistribute !== undefined) {
              this.configManager.autoDistribute = message.config.autoDistribute;
            }
            
            try {
              this.configManager._preferredColorIds = new Set(
                Array.isArray(this.configManager.guardConfig?.preferredColorIds) ? 
                this.configManager.guardConfig.preferredColorIds : []
              );
              this.configManager._excludedColorIds = new Set(
                Array.isArray(this.configManager.guardConfig?.excludedColorIds) ? 
                this.configManager.guardConfig.excludedColorIds : []
              );
              this.configManager.applyGuardConfigToForm();
              this.configManager.ensureInlineSectionsVisibility();
              this.configManager.renderAllInlineChips();
            } catch {}
            
            try {
              this.recomputeRoundPlan();
            } catch {}
          }
        }

        /**
         * Maneja la limpieza del estado Guard
         */
        handleGuardCleared(message) {
          this.log(`🧹 Guard state cleared by server`);
          try {
            const panel = document.getElementById('preview-panel');
            if (panel) panel.style.display = 'none';
            
            const fileInput = document.getElementById('project-file');
            if (fileInput) fileInput.value = '';
            
            const statusEl = document.getElementById('file-status');
            if (statusEl) statusEl.textContent = 'No file selected';
            
            const detectedEl = document.getElementById('detected-mode');
            if (detectedEl) detectedEl.textContent = 'No file loaded - mode will be auto-detected';
            
            this.projectConfig = null;
            this.detectedBotMode = null;
            this.previewManager.lastPreviewData = null;
            this.previewManager.guardPreview = {
              analysis: null,
              togglesInitialized: false,
              show: { correct: true, incorrect: true, missing: true },
              area: null
            };
            
            ['repaired-pixels', 'incorrect-pixels', 'missing-pixels'].forEach(id => {
              const el = document.getElementById(id);
              if (el) el.textContent = '0';
            });
          } catch {}
        }

        /**
         * Maneja la confirmación de upload Guard
         */
        handleGuardUploadSent(message) {
          this.log(`📤 Guard upload ACK → fav=${message.sent_to || message.slave_id || 'n/a'} size=${message.originalLength || message.size || 'n/a'} compressed=${message.compressedLength || 'n/a'}`);
        }

        /**
         * Actualiza los botones de control según el estado actual
         */
        updateControlButtons() {
          const selectedSlaves = document.querySelectorAll('.slave-toggle:checked');
          
          // Inferir modo si aún no está definido
          if (!this.detectedBotMode) {
            const looksGuard = !!(this.previewManager?.guardPreview?.analysis || 
                                 (this.previewManager?.lastPreviewData && 
                                  (this.previewManager.lastPreviewData.correctPixelsList || 
                                   this.previewManager.lastPreviewData.incorrectPixelsList || 
                                   this.previewManager.lastPreviewData.missingPixelsList || 
                                   this.previewManager.lastPreviewData.analysis || 
                                   this.previewManager.lastPreviewData.protectedArea || 
                                   this.previewManager.lastPreviewData.area)));
            const looksImage = !!(this.projectConfig?.imageData || 
                                 (this.previewManager?.lastPreviewData && 
                                  this.previewManager.lastPreviewData.imageData));
            
            if (looksGuard) this.detectedBotMode = 'Guard';
            else if (looksImage) this.detectedBotMode = 'Image';
            
            if (this.detectedBotMode) {
              const dm = document.getElementById('detected-mode');
              if (dm) dm.textContent = `Detected mode: ${this.detectedBotMode}`;
            }
          }
          
          const hasMode = this.detectedBotMode !== null;
          const hasSelected = selectedSlaves.length > 0;
          
          // Regla extra para Guard: requiere favorito y guard data cargado
          let guardReady = true;
          if (this.detectedBotMode === 'Guard') {
            const favId = this.slaveManager.getFavoriteSlaveId();
            const hasFav = !!favId;
            const hasProject = !!this.projectConfig;
            const hasGuardData = !!(this.previewManager?.guardPreview?.analysis || 
                                   (this.previewManager?.lastPreviewData && 
                                    (this.previewManager.lastPreviewData.originalPixels || 
                                     this.previewManager.lastPreviewData.analysis)));
            guardReady = hasFav && (hasProject || hasGuardData);
          }
          
          // Si hay sesión corriendo, Start siempre deshabilitado
          const isRunning = this.sessionManager.sessionStatus === 'running';
          const baseCanStart = hasSelected && hasMode && guardReady;
          const canStart = !isRunning && baseCanStart;
          
          const startBtn = document.getElementById('start-btn');
          if (startBtn) startBtn.disabled = !canStart;
          
          // Habilitar botones si hay slaves
          const hasSlaves = this.slaveManager.hasConnectedSlaves();
          const oneBatchBtn = document.getElementById('one-batch-btn');
          const oneBatchBtnPreview = document.getElementById('one-batch-btn-preview');
          
          if (oneBatchBtn) oneBatchBtn.disabled = !hasSlaves;
          if (oneBatchBtnPreview) oneBatchBtnPreview.disabled = !hasSlaves;
        }

        /**
         * Recomputa el plan de ronda actual
         */
        recomputeRoundPlan() {
          // Implementación simplificada - en el código original es más compleja
          this.currentRoundPlan = {};
          
          const selectedSlaves = Array.from(document.querySelectorAll('.slave-toggle:checked'));
          selectedSlaves.forEach(cb => {
            const slaveId = cb.value;
            const slave = this.slaveManager.slaves.get(slaveId);
            if (slave && slave.telemetry) {
              const charges = slave.telemetry.remaining_charges || 0;
              this.currentRoundPlan[slaveId] = Math.min(charges, 10); // Simplificado
              
              // Actualizar UI de cuota
              this.slaveManager.updateSlaveCardQuota(slaveId, this.currentRoundPlan[slaveId], 
                charges > 0 ? (this.currentRoundPlan[slaveId] / charges) : 0);
            }
          });
        }

        /**
         * Marca píxeles como reparados recientemente
         */
        markRecentRepairs(coords) {
          const now = Date.now();
          coords.forEach(coord => {
            const key = `${coord.x},${coord.y}`;
            this._recentRepairs.set(key, now);
          });
        }

        /**
         * Envejece las reparaciones recientes
         */
        ageRecentRepairs() {
          const now = Date.now();
          const ttl = this._recentTTL * 30000; // 30 segundos por TTL
          
          for (const [key, timestamp] of this._recentRepairs.entries()) {
            if ((now - timestamp) > ttl) {
              this._recentRepairs.delete(key);
            }
          }
        }

        /**
         * Obtiene la URL base de la API
         */
        apiBase() {
          // Convertir la URL de servidor (posiblemente ws/wss) a http/https para llamadas REST
          try {
            const serverUrl = this.webSocketManager.getServerUrl();
            if (typeof serverUrl === 'string' && serverUrl.length) {
              if (serverUrl.startsWith('ws://')) return serverUrl.replace(/^ws:\/\//, 'http://');
              if (serverUrl.startsWith('wss://')) return serverUrl.replace(/^wss:\/\//, 'https://');
              if (serverUrl.startsWith('http://') || serverUrl.startsWith('https://')) return serverUrl;
            }
          } catch {}
          const protocol = window.location.protocol === 'https:' ? 'https://' : 'http://';
          return `${protocol}${window.location.hostname}:8008`;
        }

        // Métodos delegados a los módulos correspondientes
        log(message) { return this.uiHelpers.log(message); }
        logOnce(key, message, ttl) { return this.uiHelpers.logOnce(key, message, ttl); }
        updateToggleState(id, checked) { return this.uiHelpers.updateToggleState(id, checked); }
        createCompactToggle(id, label, checked) { return this.uiHelpers.createCompactToggle(id, label, checked); }
        updateOverallProgressBar(percentage) { return this.uiHelpers.updateOverallProgressBar(percentage); }
        updateConfigPanelEnabledState() { return this.configManager.updateConfigPanelEnabledState(); }
        requestPreviewRefreshThrottle() { return this.previewManager.requestPreviewRefreshThrottle(); }
      }

      // Inicializar la aplicación
      window.dashboard = new WPlaceDashboard();
    </script>
  </body>
</html>